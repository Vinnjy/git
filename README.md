# Base-Pro:

  * ### [HEAD = "git checkout <коммит или ветка>"](#title4)
  
  * ### [Относительные ссылки (^, ~) = "git checkout <ветка или HEAD^>"](#title5)

  * ### [Перемещение ветки = "git branch -f"](#title6)
  
  * ### [Отмена изменений = "git reset или git revert"](#title7)

<br>

<br>

<br>

## <a id ="title4">HEAD</a>

* HEAD - это символическое имя **текущего выбранного коммита** — это, по сути, тот коммит, над которым мы **в данный момент** работаем.

* HEAD всегда **указывает на последний коммит из вашего локального дерева**.

* Большинство **команд Git**, изменяющих рабочее дерево, **начнут с изменения HEAD**.

* Обычно HEAD указывает на имя ветки (например, main). Когда вы делаете коммит, статус ветки main меняется и это **изменение видно через HEAD**.

### Пример.

Смотрим, где находится HEAD до коммита и после при выполненных командах (в решении).

ДО:

<img width="193" height="216" alt="image" src="https://github.com/user-attachments/assets/9ffaacc6-6626-414b-bc9d-9481bbf918b8" />

### Решение.

1. Пропишем команды:
```
git checkout C1
git checkout main
git commit
git checkout C2
```

ПОСЛЕ:

<img width="194" height="363" alt="image" src="https://github.com/user-attachments/assets/11b981f5-9dae-4564-a75f-b96294255a1d" />

* HEAD скрывался за ветке main.

### Detaching HEAD.

* **Отделение HEAD** = присвоение не ветке, а конкретному коммиту.

* Нужно для того, чтобы ***временно работать с конкретным коммитом***, не привязывая его к основной линии разработки, что позволяет экспериментировать без риска потерять данные.

* Новые коммиты, сделанные в этом состоянии, будут "осиротевшими", так как они ***не принадлежат ни одной ветке***, и их сложнее найти. 

Зачем это нужно ?

* **Изучение истории**: позволяет посмотреть на состояние проекта в прошлом, например, чтобы найти ошибку или изучить код определенного коммита.

* **Временные эксперименты**: Дает возможность проверить какой-либо код или исправление, не создавая новую ветку. Если эксперимент окажется неудачным, просто переключитесь обратно на нужную ветку, и "осиротевшие" коммиты будут проигнорированы, пока их не удалит сборщик мусора Git. 

Когда следует быть осторожным ?

* **Создание коммитов**: если вы создадите новые коммиты в состоянии "отсоединенного HEAD", они не будут прикреплены к какой-либо ветке. Это может привести к их потере.

* **Потеря данных**: Это может быть опасно, если вы забудете, что находитесь в "отсоединенном" состоянии, и случайно сделаете коммиты. Чтобы избежать этого, лучше сразу создать новую ветку для любых изменений. 

### Пример.

ДО:

* HEAD -> main -> C1.

<img width="144" height="188" alt="image" src="https://github.com/user-attachments/assets/d744bee3-b4cd-4196-a305-2336efd6a710" />

### Решение.

1. Пропишем команду:
```
git checkout C1
```
Результат:

<img width="195" height="218" alt="image" src="https://github.com/user-attachments/assets/eae41f89-fda2-47da-8da4-e73809ef4f10" />

ПОСЛЕ:

* HEAD -> C1.

### Пример.

Дано:

<img width="528" height="438" alt="image" src="https://github.com/user-attachments/assets/cec3f95d-18b3-4ebd-8625-9b2ecb1f69f9" />

1. Отделим HEAD от ветки bugFix и присвоим его последнему коммиту в этой же ветке.

2. Укажи коммит при помощи его идентификатора (hash). Hash для каждого коммита указан в кружке на схеме.

3. Нужно получить визулизацию, как на картинке.

<img width="297" height="669" alt="image" src="https://github.com/user-attachments/assets/99116e07-5c9f-41d7-8437-cf4e0d899294" />

### Решение.

1. Пропишем команду:
```
git checkout C4
```
Результат:

<img width="847" height="435" alt="image" src="https://github.com/user-attachments/assets/47a178cc-bb46-467b-8238-ad66f2e6f4bd" />

<br>

<br>

<br>

## <a id ="title5">Относительные ссылки (^, ~)</a>

* Передвигаться по дереву Git при помощи указания хешей коммитов так себе.

* В реальной ситуации у вас вряд ли будет красивая визуализация дерева в терминале, так что придётся каждый раз использовать **git log** = **чтобы найти хеш нужного коммита**.

* Более того, хеши в реальном репозитории Git намного более длинные. Например, хеш для коммита, который приведён в предыдущем уровне - fed2da64c0efc5293610bdd892f82a58e8cbc5d8.

* Git достаточно умён в работе с хешами. Ему нужны лишь первые несколько символов для того, чтобы идентифицировать конкретный коммит. Так что можно написать просто fed2 вместо колбасы выше.

С относительными ссылками можно **начать с какого-либо удобного места** (например, с ветки bugFix или от HEAD) и двигаться от него.

* **Относительные ссылки** - мощный инструмент, но мы покажем два простых способа использования:

  * **Перемещение на один коммит назад** = ***^***.
    
  * **Перемещение на несколько коммитов назад** = ***~<num>***.

### Пример.

1. Когда мы добавляем ***^*** к имени ссылки, Git воспринимает это как указание найти родителя указанного коммита.

* Так что main^ означает "первый родитель ветки main".

* main^^ означает прародитель (родитель родителя) main

2. Давайте переключимся на коммит Выше main

<img width="137" height="332" alt="image" src="https://github.com/user-attachments/assets/bb5dbd7d-9516-42cc-a681-a0041501b0b6" />

### Решение.

1. Пропишем команду:
```
git checkout main^
```
Результат:

<img width="138" height="337" alt="image" src="https://github.com/user-attachments/assets/bed77b43-0c40-47bf-acf1-949707c71a79" />

### Вместо ветки, как относительная ссылка, можно использовать HEAD.

### Пример.

1. Пройдёмся несколько раз по дереву коммитов.

<img width="140" height="335" alt="image" src="https://github.com/user-attachments/assets/5d6bf45d-3ef1-4b6c-adea-560b4b2c0495" />

### Решение.

1. Пропишем команды:
```
git checkout C3
git checkout HEAD^
git checkout HEAD^
git checkout HEAD^
```
Результат:

<img width="202" height="336" alt="image" src="https://github.com/user-attachments/assets/5175bda5-03c6-49f8-94a2-f650562af843" />

### Пример.

Дано:

<img width="515" height="434" alt="image" src="https://github.com/user-attachments/assets/544cb5d5-024d-49eb-a7ca-467aeda74a3d" />

1. Переместись на первого родителя ветки bugFix. Это отделит HEAD от ветки.

2. Нужно получить визулизацию, как на картинке.

<img width="229" height="684" alt="image" src="https://github.com/user-attachments/assets/882e287a-26aa-463b-98a8-d0ccec9ab504" />

### Решение.

1. Пропишите команду:
```
git checkout HEAD^
```
Результат:

<img width="784" height="432" alt="image" src="https://github.com/user-attachments/assets/e46675ef-5065-4184-800a-8331d29d2092" />

### Пример.

Переместиться на 4 коммита назад.

<img width="129" height="329" alt="image" src="https://github.com/user-attachments/assets/507b327a-ba6c-4c57-a5eb-bb420ca614c9" />

### Решение.

1. Пропишите команды:
```
git checkout HEAD~4
```
Результат:

<img width="198" height="343" alt="image" src="https://github.com/user-attachments/assets/9f121820-e1dd-4010-8549-28fe1e6ec0bf" />

<br>

<br>

<br>

## <a id ="title6">Перемещение ветки</a>

* Одна из наиболее распространённых целей, для которых используются ***относительные ссылки*** - **перемещение веток**.

* Можно напрямую **прикрепить ветку к коммиту** при помощи опции ***-f***, n - количество шагов назад.

1. Пропишем команду:
```
git branch -f main HEAD~n
```
* **Переместит (принудительно) ветку main на n родителей назад от HEAD**.

### Пример.

Переместить ветку main на 3 родителя назад.

<img width="154" height="339" alt="image" src="https://github.com/user-attachments/assets/deecf336-83f1-467e-b0db-232eacb2d8ef" />

### Решение.

1. Пропишем команду:
```
git branch -f main HEAD~3
```
Результат:

<img width="154" height="327" alt="image" src="https://github.com/user-attachments/assets/20580fd9-3ecc-474e-8696-5ca4f21ee32a" />

* Относительная ссылка дала нам возможность просто сослаться на C1, а branch forcing (-f) позволил быстро переместить указатель ветки на этот коммит.

### Пример.

Дано:

<img width="537" height="534" alt="image" src="https://github.com/user-attachments/assets/80538d9b-447b-4896-ae4a-2ad9760afc95" />

Передвинь HEAD, main и bugFix так, как показано на визуализации.

<img width="304" height="637" alt="image" src="https://github.com/user-attachments/assets/c2a36331-9ee9-4ef2-96d5-ad5ffa424c39" />

### Решение.

1. Пропишем команды:
```
git branch -f main C6
git branch -f bugFix HEAD~2
git checkout HEAD~1
```
Результат:

<img width="852" height="523" alt="image" src="https://github.com/user-attachments/assets/5fabdc46-e6c4-4796-a9b3-8f118b387d48" />

<br>

<br>

<br>

## <a id ="title7">Отмена изменений (reset, revert)</a>

* Есть много путей для отмены изменений в Git.

* ***На низком уровне*** = **добавление в коммит отдельных файлов и наборов строк**.

* ***На высоком*** = **как изменения реально отменяются**.

2 способа:
```
git reset
```
```
git revert
```

### git reset.

* **Отменяет изменения, перенося ссылку на ветку назад, на более старый коммит**.

* Это своего рода "переписывание истории".

* git reset перенесёт ветку назад, как будто некоторых коммитов вовсе и не было.

### Пример.

Посмотрим, как это работает.

<img width="131" height="332" alt="image" src="https://github.com/user-attachments/assets/f37c4e60-02d9-49e4-89fb-86e817fab253" />

### Решение.

1. Пропишем команду:
```
git reset HEAD~1
```
Результат:

<img width="127" height="333" alt="image" src="https://github.com/user-attachments/assets/75116e9d-6c9c-4491-afee-e752a091a4c6" />

* Git просто ***перенёс ссылку на main обратно на коммит C1***. Теперь наш локальный репозиторий в состоянии, как будто C2 никогда не существовал.

### git revert.

* Reset отлично работает **на локальных ветках**, **в локальных репозиториях**. Но этот метод переписывания истории не сработает на удалённых ветках, которые используют другие пользователи.

* Чтобы ***отменить изменения и поделиться отменёнными изменениями с остальными*** = git revert.

### Пример.

Посмотрим, как это работает.

<img width="131" height="330" alt="image" src="https://github.com/user-attachments/assets/d2bbf86f-bcd3-4d5e-9c56-6634739a519b" />

### Решение.

1. Пропишем команду:
```
git revert HEAD
```
Результат:

<img width="130" height="329" alt="image" src="https://github.com/user-attachments/assets/dbe8eff1-d356-42d1-ba12-a2d63916d251" />

* появился новый коммит. Дело в том, что ***новый коммит C2' просто содержит изменения, полностью противоположные тем, что сделаны в коммите C2***. После revert можно сделать push и поделиться изменениями с остальными.

### Пример.

Дано:

<img width="519" height="316" alt="image" src="https://github.com/user-attachments/assets/d884b7ae-776c-4e79-8888-ffd6100ce462" />

1. Отмени самый последний коммит на ветках local и pushed. Всего будет отменено два коммита (по одному на ветку).

2. Помни, что pushed - это remote ветка, а local - это локальная ветка.

3. Нужно получить визулизацию, как на картинке.

<img width="218" height="632" alt="image" src="https://github.com/user-attachments/assets/41feaec2-06d9-47a8-80d2-5dc560ff7289" />

### Решение.

1. Пропишем команды:
```
git reset local~1
git checkout pushed
git revert pushed
```
Результат:

<img width="769" height="403" alt="image" src="https://github.com/user-attachments/assets/97e7e88d-c2cb-48ef-b036-981479583a61" />
