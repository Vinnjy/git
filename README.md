# Base:

  * ### [Коммиты](#title0)

  * ### [Ветвление](#title1)

  * ### [Ветки и слияние](#title2)

  * ### [Ветки и слияние-копией](#title3)

<br>

<br>

<br>

## <a id ="title0">Коммиты</a>

* Коммит в git репозитории хранит **снимок всех файлов в директории** = **огромная копия**, только лучше.

* Git пытается быть лёгким и быстрым насколько это только возможно, так что он не просто слепо копирует всю директорию каждый раз, а ужимает (когда это возможно) коммит **в набор изменений** или «дельту» = **между текущей версией и предыдущей**.

* Git хранит **всю историю о том, когда какой коммит был сделан**. Вот почему большинство коммитов имеют предков - мы указываем на предков стрелками при визуализации. Поддержка истории коммитов более чем важна для всех, кто работает над проектом.

### Пример.

1. Визуализация небольшого git репозитория.

2. Сейчас в нём два коммита: первый, исходный коммит С0 и один коммит С1 после него, содержащий изменения.

<img width="205" height="201" alt="image" src="https://github.com/user-attachments/assets/344fada6-32ba-4a6c-b084-fe6bb554a5d4" />

### Решение.

1. Пропишем команду:
```
git commit
```
Результат:

<img width="181" height="340" alt="image" src="https://github.com/user-attachments/assets/3a25665c-510b-4fa2-9b43-2cc46132cc71" />

* Только что внесли изменения в репозиторий и сохранили их как коммит. У коммита, который мы только что сделали, есть родитель, С1, который указывает на предыдущий коммит.

### Пример.

Дано:

<img width="205" height="201" alt="image" src="https://github.com/user-attachments/assets/344fada6-32ba-4a6c-b084-fe6bb554a5d4" />

1. Сделайте 2 коммита, чтобы получить визулизацию, как на картинке.

<img width="171" height="651" alt="image" src="https://github.com/user-attachments/assets/58585f29-1b2e-4f30-8ddf-40a614cd1553" />

### Решение.

1. Пропишем в командной строке:
```
git commit
git commit
```
Результат:

<img width="155" height="415" alt="image" src="https://github.com/user-attachments/assets/f297c0d2-2c77-4087-b455-13cbdb8c5f13" />

<br>

<br>

<br>

## <a id ="title1">Ветвление</a>

* Ветки в Git, как и коммиты, невероятно легковесны. Это просто **ссылки на определённый коммит** — ничего более. Вот почему многие фанаты Git повторяют мантру: "делай ветки сразу, делай ветки часто".

* Cоздание множества веток никак не отражается на памяти или жестком диске, удобнее и проще разбивать свою работу на много маленьких веток, чем хранить все изменения в одной огромной ветке.

* Cозданная ветка хранит изменения текущего коммита и всех его родителей.

### Пример.

Создадим новую ветку с именем newImage.

<img width="205" height="201" alt="image" src="https://github.com/user-attachments/assets/344fada6-32ba-4a6c-b084-fe6bb554a5d4" />

### Решение.

1. Пропишем команду (создание ветки):
```
git branch newImage
```
Результат:

<img width="187" height="192" alt="image" src="https://github.com/user-attachments/assets/ff7e5934-8d3f-46eb-aa90-ce75b801a799" />

* Ветка newImage указывает на коммит С1.

2. Теперь сделаем коммит. Пропишем команду:
```
git commit
```
Результат:

<img width="160" height="338" alt="image" src="https://github.com/user-attachments/assets/3c29db28-b96f-4336-a47b-59d08ad44507" />

* Ветка main сдвинулась, тогда как ветка newImage - нет. Всё из-за того, что мы не переключились на новую ветку, а остались в старой, о чём говорит звёздочка около ветки main.

3. Чтобы сделать коммит для ветки newImage, нужно **переключиься на ветку**, а затем сделать коммит. Вернёмся к пукнту 1:

<img width="187" height="192" alt="image" src="https://github.com/user-attachments/assets/ff7e5934-8d3f-46eb-aa90-ce75b801a799" />

4. Пропишем 2 команды:
```
git checkout newImage
git commit
```
Результат:

<img width="158" height="339" alt="image" src="https://github.com/user-attachments/assets/d6da4af7-1528-4e12-afe8-99c20183cc99" />

### Пример.

Дано:

<img width="169" height="170" alt="image" src="https://github.com/user-attachments/assets/eac38e5f-e298-4e90-8a45-559f0b8dbd87" />

1. Создай ветку с именем bugFix и переключись на неё.

2. Нужно получить визулизацию, как на картинке.

<img width="167" height="342" alt="image" src="https://github.com/user-attachments/assets/e77783db-5e0b-4aa0-8aaf-8f338bdd0725" />

### Решение.

1. Пропишем команду:
```
git checkout -b bugFix
```
* Создаст ветку и переключиться на неё.

Результат:

<img width="160" height="165" alt="image" src="https://github.com/user-attachments/assets/ff978f1d-36f4-4090-9f86-416376771299" />

<br>

<br>

<br>

## <a id ="title2">Ветки и слияние (merge)</a>

+ Как объединять изменения из двух разных веток.

   * Очень удобно создать ветку, сделать свою часть работы в ней и потом объединить изменения из своей ветки с общими.

+ Первый способ объединения изменений, который мы рассмотрим - **git merge** - слияние.

   * Слияния в Git создают особый вид коммита, который **имеет сразу двух родителей**. Коммит с двумя родителями обычно означает, что мы хотим **объединить изменения из одного коммита с другим коммитом и всеми их родительскими коммитами**.

### Пример.

1. Две ветки, каждая содержит по одному уникальному коммиту.

2. Это означает, что ни одна из веток не содержит полный набор "работ", выполненных в этом репозитории.

3. Можно исправить эту ситуацию, выполнив слияние.

<img width="241" height="374" alt="image" src="https://github.com/user-attachments/assets/111b05fd-c3b3-4f66-a591-53bfce5cfb26" />

### Решение.

1. Пропишем комвнду (слияние bugFix в main):
```
git merge bugFix
```
Результат:

<img width="295" height="363" alt="image" src="https://github.com/user-attachments/assets/103822a7-af38-4101-8df9-b8a55b6a6c86" />

+ Ветка main теперь указывает на коммит, у которого два родителя.

   * Если проследовать по стрелкам от этого коммита, вы пройдёте через каждый коммит в дереве прямиком к началу.

   * Это означает, что теперь **в ветке main содержатся все изменения репозитория**.


   * У каждой ветки — свой цвет. Каждый коммит становится того цвета, какого его ветка.

   * Если в нём изменения сразу двух веток - он становится цветом, смешанным из цветов родительских веток.

   * Цвет ветки main подмешан к каждому коммиту, а ветки bugFix - нет.

### Продлжим пример.

Cделаем слияние ветки main в ветку bugFix.

2. Пропишем комвнды:
```
git checkоut bugFix
git merge main
```
Результат:

<img width="263" height="383" alt="image" src="https://github.com/user-attachments/assets/c1ac4f63-e714-47d1-92ff-11285a45896b" />

* Так как ветка bugFix была предшественницей main, Git не делал ничего, только сдвинул bugFix на тот же коммит, где находится main.

* Теперь все коммиты одного цвета, что означает, что каждая ветка содержит все изменения репозитория.

### Пример.

Дано:

<img width="184" height="174" alt="image" src="https://github.com/user-attachments/assets/0efa73d2-fb33-451a-8e54-8974a19a1765" />

1. Создай новую ветку под названием bugFix.

2. Переключись на новую ветку bugFix командой git checkout bugFix.

3. Сделай один коммит.

4. Вернись на ветку main при помощи git checkout.

5. Сделай ещё один коммит.

6. Слей ветку bugFix с веткой main при помощи git merge.

7. Нужно получить визулизацию, как на картинке.

<img width="248" height="684" alt="image" src="https://github.com/user-attachments/assets/2422e86b-c625-4d40-8e1e-c321a864b4c5" />

### Решение.

1. Пропишем команды:
```
git checkout -b bugFix
git commit
git checkout main
git commit
git merge bugFix
```
Результат:

<img width="793" height="439" alt="image" src="https://github.com/user-attachments/assets/a5fe328d-df90-421b-a8f6-8d9aec0e04a2" />

<br>

<br>

<br>

## <a id ="title3">Ветки и слияние (rebase)</a>

* Oбъединения изменений в ветках - это rebasing. При ребейзе Git **по сути копирует набор коммитов и переносит их в другое место**.

* Преимущество rebase в том, что c его помощью можно делать чистые и красивые линейные последовательности коммитов. История коммитов будет чище, если вы применяете rebase.

### Пример.

1. Две ветки.
  
2. Выбрана ветка bugFix (отмечена звёздочкой).

3. Сдвинуть наши изменения из bugFix прямо на вершину ветки main.
   
4. Благодаря этому всё будет выглядеть, как будто эти изменения делались последовательно, хотя на самом деле - параллельно.

<img width="262" height="370" alt="image" src="https://github.com/user-attachments/assets/050f2a8a-afb4-47b5-83f4-f4c2fbd3295b" />

### Решение.

1. Пропишем командцу:
```
git rebase main
```
Результат:

<img width="253" height="334" alt="image" src="https://github.com/user-attachments/assets/625ea1a9-b18d-4251-8301-f4b1d688a60b" />

* изменения из bugFix находятся в конце ветки main и являют собой линейную последовательность коммитов.

* С3' - это его "копия" в ветке main.

+ **Ветка main не обновлена до последних изменений**

2. Пропишем команду:
```
git checkout main
```
Результат:

<img width="243" height="334" alt="image" src="https://github.com/user-attachments/assets/1051ad1c-8afd-4196-a67e-f8b6833f7687" />

3. Пропишем команду:
```
git rebase bugFix
```
Результат:

<img width="247" height="329" alt="image" src="https://github.com/user-attachments/assets/13789d63-182a-4af5-8ef1-3307f23a0e72" />

* Так как ветка main был предком bugFix, git просто сдвинул ссылку на main вперёд.

### Пример.

Дано:

<img width="145" height="162" alt="image" src="https://github.com/user-attachments/assets/26bc6d56-318e-49ad-9a3d-6bd9b4fb0643" />

1. Переключись на ветку bugFix.

2. Сделай коммит.

3. Вернись на main и сделай коммит ещё раз.

4. Переключись на bugFix и сделай rebase на main.

5. Нужно получить визулизацию, как на картинке.

<img width="323" height="637" alt="image" src="https://github.com/user-attachments/assets/56618dcd-479f-49a3-b3cc-70e8d73c1930" />

### Решение.

1. Пропишем команды:
```
git checkout -b bugFix
git commit
git checkout main
git commit
git checkout bugFix
git rebase main
```
Результат:

<img width="868" height="407" alt="image" src="https://github.com/user-attachments/assets/516bef45-4136-455f-95af-f9414c616df2" />
