# Удалённые репозитории:

## Pull & Push

  * ### [Клонирование = "git clone"](#title17)

  * ### [Удалённые ветки = "git checkout origin/main"](#title18)

  * ### [Извлечение/скачивание данных из удаленного репозитория = "git fetch"](#title19)

  * ### [git fetch и git merge = "git pull"](#title20)

  * ### [Коллективная работа = "git fakeTeamwork"](#title21)

  * ### [Загрузка изменений в удалённый репозиторий = "git push"](#title22)

  * ### [Расхождение в истории = "git pull --rebase + git push или git pull + git push"](#title23)

  * ### [Заблокированная ветвь main = "git checkout -b <ветка и коммит> + git push"](#title24)

<br>

<br>

<br>

## <a id ="title17">Клонирование</a>

* Удалённые репозитории — копии репозитория, хранящиеся на другом компьютере. Можете связываться с этим компьютером через Интернет, что позволяет вам передавать коммиты туда и сюда.

Свойства:

* ***средство резервного копирования***. Локальные репозитории способны восстанавливать файлы, используя предыдущие состояния, но информация хранится локально. Потеряв все свои локальные данные, способны восстановить их при наличии копии своего репозитория на другом компьютере.

* ***процесс разработки более социальным***. Когда копия проекта размещена в другом месте, коллеги запросто могут внести свой вклад в ваш проект или забрать последние и актуальные изменения.

### git clone.

* **git clone в реальной жизни** - ***создаст локальную копию удалённого репозитория*** (например, с GitHub).

* В тренажёре - ***создаёт удалённый репозиторий на основе вашего локального репозитория***. На самом деле, это является полной противоположностью реальной команды.

### Пример.

<img width="128" height="189" alt="image" src="https://github.com/user-attachments/assets/5cea807c-b6c2-4f9d-94b2-d239a6f3db82" />

### Решение.

1. Пропишем команду:
```
git clone
```
Результат:

<img width="314" height="182" alt="image" src="https://github.com/user-attachments/assets/71a71bec-063f-4b22-9a7d-6858a94b61d4" />

<br>

<br>

<br>

## <a id ="title18">Удалённые ветки</a>

* В локальном репозитории по предыдущему примеру появилась новая ветка с именем **o/main** = ***удалённой веткой***.

Свойтва:

* ***Отражают состояние удалённых репозиториев*** (с того момента, как обращались к этим удалённым репозиториям в последний раз).

* ***Отслеживать разницу между вашими локальными наработками и тем, что было сделано другими участниками***.

* ***Извлечение их, отделяет*** = **detaching HEAD**. Git делает это потому, что не можете работать непосредственно в этих ветках; сперва вам необходимо сделать наработки где-либо, а уж затем делиться ими с удалёнными репозиториями (после чего удалённые ветки будут обновлены).

### Что такое "o/" в названии ветки?

* **o/** в названии ветки = обозначениe ***удалённых веток***.

Формате:
```
<удалённый репозиторий>/<имя ветки>
```
* Имя ветки **o/main**:

  * ***main** = ***имя ветки***.

  * **o** = ***имя удалённого репозитория***.

* ***В работе не как o, а как origin***.

### Пример.

1. Извлечём (check out) удалённую ветку и посмотрим что произойдёт.

<img width="314" height="180" alt="image" src="https://github.com/user-attachments/assets/cbf38397-ee78-4924-a7cc-6c26b655ce8a" />

### Решение.

1. Пропишем команды:
```
git checkout o/main
git commit
```
Результат:

<img width="315" height="314" alt="image" src="https://github.com/user-attachments/assets/af72ea7f-e4d8-4a30-841d-9defe1ad7688" />

* ***Отделил detached HEAD и не обновил o/main, когда мы добавили новый коммит***. Всё потому, что o/main обновится тогда и только тогда, когда обновится сам удалённый репозиторий.

### Пример.

Дано:

<img width="592" height="268" alt="image" src="https://github.com/user-attachments/assets/f7b86e30-2b0c-4295-b781-a52a4d4a548a" />

1. Выполните коммит единожды на main, а затем на o/main (предварительно переключившись на эту ветку). Это наглядно продемонстрирует поведение удалённых веток, а также покажет, как изменения влияют на состояние удалённых репозиториев.

2. Нужно получить визулизацию, как на картинке.

<img width="300" height="625" alt="image" src="https://github.com/user-attachments/assets/85badfd5-4b38-4691-9e53-160c38204c94" />

### Решение.

1. Пропишем команды:
```
git commit
git checkout o/main
git commit
```
Результат:

<img width="930" height="295" alt="image" src="https://github.com/user-attachments/assets/71c9bfae-16cd-48ba-99b0-88ea65174c16" />

<br>

<br>

<br>

## <a id ="title19">Извлечение данных из удалённого репозитория</a>

Работа с удалёнными git репозиториями сводится к передаче данных "в и из" других репозиториев. 

Отправляя коммиты туда-обратно, можем делиться любыми изменениями, которые отслеживает git (следовательно, делиться новыми файлами, свежими идеями, любовными письмами и т.д.).

### git fetch.

* ***Извлечение данных из удалённого репозитория*** = **git fetch**.

* ***Как только изменим представление удалённого репозитория, удалённые ветки обновятся соответствующим образом и отобразят это представление***.

### Пример.

Имеется удалённый репозиторий, который содержит в себе два коммита, отсутствующих в нашем локальном репозитории.

<img width="300" height="314" alt="image" src="https://github.com/user-attachments/assets/88614291-f792-4cfd-a7a7-1fdfa8b2214a" />

### Решение.

1. Пропишем команду:
```
git fetch
```
Результат:

<img width="305" height="316" alt="image" src="https://github.com/user-attachments/assets/4f0c6319-9e74-4bc1-bc60-af0170617f94" />

* Коммиты C2 и C3 были успешно скачаны в локальный репозиторий.

* Удалённая ветка o/main отобразила эти изменения соответствующим образом.

### Что делает fetch.

**git fetch** выполняет две операции:

1. ***Cвязывается с указанным удалённым репозиторием*** и ***забирает все те данные проекта, которых у вас ещё нет***, при этом...

2. Должны ***появиться ссылки на все ветки из этого удалённого репозитория*** (например, o/main).

Фактически, ***git fetch синхронизирует локальное представление удалённых репозиториев*** с тем, что является актуальным на текущий момент времени.

* **git fetch** 'общается' с удалёнными репозиториями посредством Интернета (через такие протоколы, как http:// или git://).

### Чего fetch не делает

* ***git fetch забирает данные в ваш локальный репозиторий***, но не сливает их с какими-либо вашими наработками и не модифицирует то, над чем вы работаете в данный момент.

Важно это помнить и понимать, потому что многие разработчики думают, что, запустив команду git fetch, они приведут всю свою локальную работу к такому же виду, как и на удалённом репозитории. Команда всего лишь скачивает все необходимые данные, но вам потребуется вручную слить эти данные с вашими, когда вы будете готовы.

* **git fetch** = процедура скачивания новые данные из удаленного репозитория, но не сливает их с вашими локальными файлами.

### Пример.

Дано:

<img width="761" height="521" alt="image" src="https://github.com/user-attachments/assets/cc18ce7b-a369-4a71-a8fa-fe4509e3d47a" />

1. Запустите git fetch и скачайте все коммиты!

2. Нужно получить визулизацию, как на картинке.

<img width="300" height="605" alt="image" src="https://github.com/user-attachments/assets/1a299729-bd53-49f3-98b9-bea9f9573311" />

### Решение.

1. Пропишем команду:
```
git fetch
```
Результат:

<img width="1140" height="525" alt="image" src="https://github.com/user-attachments/assets/c95d9416-d59b-4395-b183-71da1350c7e0" />

<br>

<br>

<br>

## <a id ="title20">git fetch и git merge = "git pull"</a>

git pull состоит из двух команд: 

* **git fetch** = ***загрузка изменений из удаленного репозитория***. Cкачивает новые данные из удаленного репозитория, но не сливает их с вашими локальными файлами.

* **git merge** = ***слияние загруженных изменений с локальной веткой***. Объединяет новые изменения из удаленной ветки с текущей локальной веткой.

* **Коммит слияния**: Если слияние происходит успешно, git автоматически создаст новый "коммит слияния" для фиксации этих изменений. Этот коммит будет иметь два родительских элемента: родительский коммит из вашей локальной ветки и коммит из ветки, которую вы скачали.

### Пример.

<img width="303" height="317" alt="image" src="https://github.com/user-attachments/assets/7c2ee2a6-a0e5-4819-b4ea-faa31f4948e1" />

### Решение.

1. Пропишем команды:
```
git fetch
git merge
```
```
git pull
```
Результат:

<img width="353" height="315" alt="image" src="https://github.com/user-attachments/assets/157439f7-c02f-4760-82a5-dd8467be42aa" />

* Cкачали C3 с помощью команды fetch и затем объединяем эти наработки с помощью git merge o/main.

* Ветка main отображает изменения с удалённого репозитория (в данном случае — с репозитория origin).

* git pull существенно уменьшает работу, если бы использовали git fetch и слияние (merging) скачанной ветки.

### Пример.

Дано:

<img width="595" height="265" alt="image" src="https://github.com/user-attachments/assets/75881f3f-39fe-4c96-9b34-2af9349d855d" />

1. Нужно получить визулизацию, как на картинке.

<img width="332" height="576" alt="image" src="https://github.com/user-attachments/assets/5432d9f2-5ead-4d8b-96e5-cff6133b9bad" />

### Решение.

1. Пропишем команду:
```
git pull
```
Результат:

<img width="1027" height="378" alt="image" src="https://github.com/user-attachments/assets/657c554a-285b-4d10-babf-0be6425b4976" />

<br>

<br>

<br>

## <a id ="title21">Коллективная работа</a>

Cкачивать наработки и изменения, которые были сделаны в удалённом репозитории.

Это означает, что нам следует "сделать вид", как будто знаем о том, что удалённый репозиторий, с которым работаем, был изменён одним из ваших коллег / друзей / единомышленников. Это может быть какая-то ветка, либо же какой-то конкретный коммит.

### git fakeTeamwork.

* Поведение команды ***fakeTeamwork*** по умолчанию заключается в том, чтобы просто ***"инициировать" коммит на main***.

### Пример.

<img width="301" height="175" alt="image" src="https://github.com/user-attachments/assets/d76ce4ba-7e38-4d50-aee5-782014f87aa0" />

### Решение.

1. Пропишем команду:
```
git fakeTeamwork
```
Результат:

<img width="298" height="314" alt="image" src="https://github.com/user-attachments/assets/17ff5b3d-0ebd-449e-872a-54e1036366e0" />

* Удалённый репозиторий был изменён при помощи добавления нового коммита.

### Пример.

<img width="300" height="197" alt="image" src="https://github.com/user-attachments/assets/60fe0e4f-88aa-4c06-9a1c-49d33a5a8989" />

### Решение.

1. Пропишем команду:
```
git fakeTeamwork foo 3
```
Результат:

<img width="301" height="311" alt="image" src="https://github.com/user-attachments/assets/d7eebe39-c462-4720-8529-cd6f3423b766" />

* Добавление трёх коммитов в ветку foo на удалённом репозитории.

### Пример.

Дано:

<img width="104" height="141" alt="image" src="https://github.com/user-attachments/assets/bb0c35b5-4f0b-4805-a797-fe8159a6f315" />

1. Склонируйте удалённый репозиторий (с помощью git clone), симулируйте любые изменения на этом удалённом репозитории, сделайте какие-нибудь коммиты и затем скачайте "чужие" изменения.

2. Нужно получить визулизацию, как на картинке.

<img width="333" height="602" alt="image" src="https://github.com/user-attachments/assets/3b1e29e9-c8c5-48ab-b883-545400845d74" />

### Решение.

1. Пропишем команды:
```
git clone
git fakeTeamwork main 2
git commit
git pull
```
Результат:

<img width="1028" height="483" alt="image" src="https://github.com/user-attachments/assets/40ae23e3-c4d7-4dc5-a4d7-2302fb18f69f" />

<br>

<br>

<br>

## <a id ="title22">Загрузка изменений в удалённый репозиторий</a>

Cкачали изменения с удалённого репозитория и включили их в локальные наработки. 

### Но как нам поделиться своими наработками и изменениями с другими участниками проекта?

Способ противоположным тому, которым пользовались ранее ***для скачивания наработок*** = **git pull**. Cпособ - использование команды **git push**.

* **git push** отвечает:

  * ***за загрузку ваших изменений в указанный удалённый репозиторий***.
  
  * ***включение локальных коммитов в состав удалённого репозитория***.

* **git push** = "публикацию" своей работы.

### Замечание.

Поведение команды git push без аргументов варьируется в зависимости от значения push.default, указанной в настройках git. Значение по умолчанию зависит от версии git, которую вы используете. Здесь используется значение = upstream.

### Пример.

1. У нас имеются изменения, которых нет в удалённом репозитории. Давайте же закачаем их туда!

<img width="300" height="310" alt="image" src="https://github.com/user-attachments/assets/9218c97d-74cf-4c89-9d2d-ce65280c9aff" />

### Решение.

1. Пропишем команду:
```
git push
```
Результат:

<img width="298" height="309" alt="image" src="https://github.com/user-attachments/assets/e82e5ad0-9331-405b-998d-3e9920a542c6" />

* Удалённый репозиторий получил новый коммит C2.

* Ветка main на удалённом репозитории теперь указывает на C2.

* Локальное отображение удалённого репозитория (o/main) изменилось соответственно. Всё синхронизировалось.

### Пример.

Дано:

<img width="590" height="150" alt="image" src="https://github.com/user-attachments/assets/4b830ea8-f493-47b3-b7b7-da30a48b89b2" />

1. Просто поделитесь своими двумя новыми коммитами с удалённым репозиторием

2. Нужно получить визулизацию, как на картинке.

<img width="288" height="573" alt="image" src="https://github.com/user-attachments/assets/cbb51e04-e7f0-4ca1-a7e2-953bc32e7a2c" />

### Решение.

1. Пропишем команды:
```
git commit
git commit
git push
```
Результат:

<img width="841" height="371" alt="image" src="https://github.com/user-attachments/assets/60da85ea-091f-4e6b-93c7-44bea0b38328" />

<br>

<br>

<br>

## <a id ="title23">Расхождение в истории</a>

* Как забирать = pull = чужие коммиты.

* Как закачивать = push = свои наработки и изменения.

***Нюансы возникают тогда, когда история репозитория расходится***.

1. Допустим, склонировали репозиторий в понедельник и начали разрабатывать какую-то новую и уникальную часть приложения. 

2. В пятницу вечером готовы опубликовать фичу. 

3. Но, о нет! Ваш коллега в течение недели написал кучу кода, который делает все наработки устарелыми. Код был также закоммичен и опубликован на удалённом репозитории, поэтому код базируется на устаревшей версии проекта и более не уместен.

   * В этом случае использование команды git push является сомнительным. 

   * Как поведёт себя команда git push, если вы её выполните? 

   * Может быть, она изменит удалённый репозиторий и вернёт всё к тому состоянию, которое было в понедельник? 

   * Может, команда попробует добавить ваш код, не удаляя при этом новый? Или же она проигнорирует ваши изменения, так как они уже устарели?

4. По причине того, что в данной ситуации (когда история расходится) слишком много двусмысленностей и неопределённостей, git не даст закачать (push) ваши изменения.

   * Принуждать ***включить в состав своей работы все те последние наработки и изменения, которые находятся на удалённом репозитории***.
  
### Пример.

<img width="298" height="311" alt="image" src="https://github.com/user-attachments/assets/96124b2a-a849-46e6-8c80-a59fe4025124" />

### Решение.

1. Пропишем команду:
```
git push
```
Результат:

<img width="298" height="311" alt="image" src="https://github.com/user-attachments/assets/96124b2a-a849-46e6-8c80-a59fe4025124" />

* Ничего не произошло.

* Всё потому, что команда git push не выполнилась успешно.

* Дело в том, что ваш последний коммит C3 основан на удалённом коммите C1. В свою очередь, удалённый репозиторий уже изменился под воздействием C2. Вот почему git отклонил ваш push.

### Вариант 1.

* ***Перебазировать свою работу на самую последнюю версию удалённой ветки***.

Существует множество способов сделать это, но наиболее простой способ 'сдвинуть' свои наработки - через перебазировку или rebasing.

### Пример.

<img width="298" height="311" alt="image" src="https://github.com/user-attachments/assets/96124b2a-a849-46e6-8c80-a59fe4025124" />

### Решение.

1. Пропишем команды:
```
git fetch
git rebase o/main
git push
```
Результат:

<img width="387" height="316" alt="image" src="https://github.com/user-attachments/assets/12c973d0-8fc8-448b-b38e-9e198eaeb0b0" />

* Обновили локальный образ удалённого репозитория средствами git fetch.

* Перебазировали наработки, чтобы отражали все изменения с удалённого репозитория.

* Опубликовали их с помощью git push.

### Вариант 2.

* **git merge** ***не передвигает ваши наработки*** = ***создаёт новый коммит, в котором Ваши и удалённые изменения объединены***.

* Такой способ помогает указать git на то, что ***собираетесь включить в состав ваших наработок все изменения с удалённого репозитория*** = ***ваш коммит отразится на всех коммитах удалённой ветки***, поскольку удалённая ветка является предком вашей собственной локальной ветки.

### Пример.

Если мы объединим (merge) вместо перебазирования (rebase)..

<img width="300" height="311" alt="image" src="https://github.com/user-attachments/assets/9abfb263-18a3-4287-b0d7-c32def4ffb35" />

### Решение.

1. Пропишем команды:
```
git fetch
git merge o/main
git push
```
Результат:

<img width="321" height="347" alt="image" src="https://github.com/user-attachments/assets/3dffae11-baf9-4c73-9f85-f4f82806a450" />

* Обновили локальное представление удалённого репозитория с помощью git fetch.

* Объединили ваши новые наработки с нашими наработками (чтобы отразить изменения в удалённом репозитории).

* Затем опубликовали их с помощью git push.

### Вариант 3.

* **git pull --rebase** = ***аналог для совместно вызванных fetch и rebase***.

### Пример.

<img width="297" height="311" alt="image" src="https://github.com/user-attachments/assets/3c29ce53-e10d-45b1-9e8c-9292f02820b0" />

### Решение.

1. Пропишем команды:
```
git pull --rebase
git push
```
Результат:

<img width="385" height="320" alt="image" src="https://github.com/user-attachments/assets/1907fb2c-50f5-4259-b2fd-919f46fafb2c" />

* Тот же результат, как и ранее, но намного короче вызов команд.

### Вариант 4.

### Пример.

<img width="300" height="309" alt="image" src="https://github.com/user-attachments/assets/72ef9acf-80f0-4c50-8771-a6b56d3c7590" />

### Решение.

1. Пропишем команды:
```
git pull
git push
```
Результат:

<img width="317" height="343" alt="image" src="https://github.com/user-attachments/assets/e50679c6-04b8-431e-935f-35211c3bc820" />

* И снова - результат такой же, как и ранее.

### Пример.

Дано:

<img width="119" height="156" alt="image" src="https://github.com/user-attachments/assets/60ed6282-91b6-4d7e-a68f-54dfdc8e82b8" />

1. Рабочий процесс получения изменений (fetching), перебазирования/объединения (rebase/merging) и публикации изменений (pushing):

   * Склонируйте репозиторий.

   * Сфабрикуйте командную работу (1 коммит).

   * Сделайте свой собственный коммит (1 коммит).

   * Опубликуйте свои наработки посредством перебазировки (rebasing).

2. Нужно получить визулизацию, как на картинке.

### Решение.

1. Пропишем команды:
```
git clone
git fakeTeamwork main 1
git commit
git pull --rebase
git push
```
Результат:

<img width="1173" height="377" alt="image" src="https://github.com/user-attachments/assets/d0e19f20-c9ed-46c0-8418-9430bd2b7f4a" />

<br>

<br>

<br>

## <a id ="title24">Заблокированная ветвь main</a>

### Remote Rejected!

Когда работаете в составе большой команды разработчиков над проектом, то, вероятнее всего, ветвь main будет заблокирована. 

Для внесения изменений в неё в git существует ***понятие запроса на слияние Pull Request***. В такой ситуации если закоммитите свои наработки непосредственно в main ветвь, а после выполните git push, то будет сгенерировано сообщение об ошибке:
```
! [remote rejected] main -> main (TF402455: Pushes to this branch are not permitted; you must use a pull request to update this branch.)
! [удалённо отклонено] main -> main (TF402455: Изменение этой ветви запрещены; вы можете использовать pull request для обновления этой ветви.)
```

### Почему произошло отклонение моих изменений?

Удалённый репозиторий отклонил загруженные коммиты непосредственно в main ветку потому, что ***на main настроена политика, которая требует использование Pull request вместо обычного git push***:

* Политика подразумевает ***процесс создания новой ветви разработки***, ***внесение в неё всех необходимых коммитов***, ***загрузка изменений в удалённый репозиторий и открытие нового Pull request***.

### Пример.

Дано:

<img width="588" height="269" alt="image" src="https://github.com/user-attachments/assets/8fe5cec0-6cfa-455f-ae51-876697c02ebe" />

1. Создайте ещё одну ветвь под названием feature.

2. Отправьте изменения на удалённый репозиторий.

3. Не забудьте вернуть локальную main ветвь в исходное состояние (чтобы она была синхронизирована с удалённой). В противном случае у вас могут возникнуть проблемы при следующем выполнении git pull.

4. Нужно получить визулизацию, как на картинке.

<img width="302" height="575" alt="image" src="https://github.com/user-attachments/assets/ccd34ed7-bf00-45c3-a6ad-119229578b10" />

### Решение.

1. Пропишем команды:
```
git branch -f main o/main
git checkout -b feature C2
git push 
```
Результат:

<img width="853" height="262" alt="image" src="https://github.com/user-attachments/assets/ee3d9383-7f5a-4784-aed0-7caa9c88f39b" />
